---
title : "운영체제 (4) : 스케줄링 알고리즘, 인터럽트"
excerpt : "FIFO, SJF, Priority-based, RobinRound"
category :
  - os
tag :
  - os
use_math : true
author_profile : true
header:
  teaser : /assets/images/category/os.jpg
  overlay_image : /assets/images/category/os.jpg
  overlay_filter: 0.1
---



## **프로세스** 

**프로세스**: 실행 중인 프로그램
프로세스는 메모리에 올려진다음
모든 코드는 메모리에 올려진다음 한줄씩 cpu에 넣어져서 실행됩니다.  

코드 이미지(바이너리)는 일종의 실행 파일이며, 리눅스 계열에서는 ELF 포맷으로 되어있습니다.   

**프로세스 = 작업 = task = job**  

작은 차이가 있긴하지만 유사한 용어로 혼용이 됩니다.

응용프로그램은 프로세스와는 다른 개념입니다. 응용 프로그램은 여러개의 프로세스로 이루어질 수 있습니다. 특히 유닉스 계열에서는 하나의 응용 프로그램이 사용자가 원하는 기능을 위해서 여러개의 프로세스가 서로 상호작용하며 실행되기도 합니다. 간단한 프로그램의 경우 하나의 프로세스로 구성될 수도 있습니다.  

## **스케쥴링 정책 policy = 스케쥴링 알고리즘**

**스케쥴러**: 누가 프로세스 실행을 관리할 것인지  

**스케쥴링 알고리즘**: 어느 순서대로 프로세스를 실행시킬 것인지에 대한 알고리즘
    -시분할 시스템: 프로세스 응답 시간 최소화
    - 멀티 프로그래밍: cpu 활용도를 최대화
    - FIFO 스케쥴러
    - SJF 스케쥴러
    - RobinRound 스케쥴러  

### **스케쥴링 알고리즘: FIFO 스케쥴러**
<center>
<img src="../assets/img/os/fifo1.png" style="width:90%;">
<img src="../assets/img/os/fifo2.png" style="width:90%;">
</center>

프로세스가 저장매체를 읽거나, 프린팅을 하는 등 다른 작업을 하지 않고 처음부터 끝까지 cpu만 사용하는 프로그램이라고 가정합니다.

가장 간단한 스케쥴러입니다. 배치 처리 시스템과 유사합니다. FCFS(First Come First Served) 스케쥴러라고도 합니다. 

### **스케쥴링 알고리즘 : SJF Short Job First 스케쥴러**

<center>
<img src="../assets/img/os/sjf.png" style="width:90%;">
</center>

SJF Shortest Job First 최단 작업 우선 알고리즘으로, 실행시간이 짧은 프로세스부터 순서대로 실행을 시킵니다. FIFO에 비해 응답시간이 더 짧을 수 있습니다. 



RTOS RealTime OS : 응용 프로그램 실시간 성능 보장을 목표로 하는 OS
- 정확하게 프로그램 시작, 완료 시간을 보장해야 합니다. 
- 시간에 민감한 프로그램을 돌려야하는 환경.
- 하드웨어 RTOS, 소프트웨어 RTOS

GPOS General Purpose OS : 프로세스 실행 시간에 민감하지 않고 일반적인 목적으로 사용되는 OS
- 윈도우, 리눅스

### **스케쥴링 알고리즘 : Priority-Based 스케쥴러**

<center>
<img src="../assets/img/os/priority.png" style="width:90%;">
</center>

Priority-Based 우선순위 기반 스케쥴러
프로세스에 미리 우선순위를 매겨놓고, 그 순서로 프로세스를 실행시킵니다.우선순위를 매기는 기준은 정하기 나름입니다.
- 정적 우선 순위: 프로세스마다 우선순위를 미리 지정합니다.
    - 예) 카카오톡 관련 프로세스는 우선순위를 낮게, 
- 동적 우선 순위: 스케쥴러가 상황에 따라 우선순위를 동적으로 변경해줍니다. 
    - 예) 실행한지 매우 오래된 응용 프로그랢이 있으면 우선순위를 동적으로 높게 매깁니다. 

### **스케쥴링 알고리즘 : Round Robin 스케쥴러**

<center>
<img src="../assets/img/os/robinround1.png" style="width:90%;">
</center>

시분할 시스템을 기본으로 합니다. 프로세스를 잘게 쪼개서, 적절히 다른 프로세스로 전환하면서 프로그램을 처리합니다. 

<center>
<img src="../assets/img/os/robinround2.png" style="width:90%;">
</center>

#### **정리**

|스케쥴링 알고리즘|설명|
|--|--|
|FIFO|배치 처리 시스템과 유사|
|SJF|Short Job First|
|Priority-Based|정적 우선순위/동적 우선순위|
|RoundRobin|시분할 시스템 기반|


## **프로세스 상태**
<center>
<img src="../assets/img/os/processstate.png" style="width:70%;">
</center>

- **``ready (실행 가능)``** : cpu에서 실행 가능 대기 상태
- **``running (실행 중)``** : 현재 cpu에서 실행 중. 만약 싱글 코어 프로세서라면, running인 프로세스는 최대 1개, 최소 0개 입니다.
- **``block (대기)``** : wait상태와 같음. 특정 이벤트 발생 대기 상태. 만약 저장 매체에 파일 읽기를 요청했다고 했을 때, 프로세스는 파일 읽기를 할때까지 기다리는데 이것이 block상태입니다. 파일을 다 읽으면 ready상태로 돌아갑니다.
- **``exit (종료)``**: 시스템 리소스를 풀어주려고 하는 상태.

## **프로세스 상태 간 관계**
<center>
<img src="../assets/img/os/processstate2.png" style="width:50%;">
</center>

- ``running 상태``에서부터 시작
- (1) 파일 읽기를 요청하면 ``block 상태``로 변합니다.
- (2) 파일 읽기가 끝나면 ``ready 상태``로 갑니다. 스케쥴러는 다음에 실행할 프로세스가 뭐가 있는지 확인할 때 ready상태인 프로세스가 무엇인지 봅니다.
- (3) 프로세스가 ``running 상태``로 바뀝니다. 
- (4) 시분할 시스템에서는 주기적으로 다른 프로세스로 바꿔주는데, 이때 running하던 프로세스를 ``ready 상태``로 바꿔줍니다. 




## 프로세스의 순서를 정하는 Queue

ready 상태인 프로세스가 여러개일 때, 어떤 프로세스부터 run해야할까? 그에 대한 계획이 필요합니다. 이때 Queue라는 자료구조를 이용해서 실행할 프로세스의 순서를 정합니다.

- Ready State Queue
- Running State Queue
- Block State Queue

(그림)


## 선점형 스케줄러와 비선점형 스케줄러  

**비선점형 스케줄러** (FIFO, SJF, Priority-based)
- 하나의 프로세스가 끝나야만 다른 프로세스가 cpu를 사용할 수 있음. 
- 다른 말로는, 시분할 시스템을 쓸 수 없는 스케줄러이다. 
- 이전의 프로세스A가 자발적으로 wait(block)상태가 되거나, 실행이 끝나서 end상태가 되어야만, 다른 프로세스인 B로 교체할 수 있습니다.

**선점형 스케줄러** (RoundRobin, 시분할 시스템의 하나)
- 하나의 프로세스가 다른 프로세스 대신에 cpu를 차지할 수 있음. 
- A라는 프로세스를 ready state로 강제로 바꾼다음, B라는 프로세스를 수행하게 할 수 있습니다. 
- 이전 프로세스 A가 running 중일떄도 강제로 중지시키고 이후 프로세스 B로 교체할 수 있습니다.
- Running->Ready 상태로 바꿀 수 있다.
- 다른 프로세스를 Running 상태로 전환할 수 있다.  


기존의 스케줄러는 비선점형 스케줄러가 기본이었습니다. 기존의 프로세스를 강제로 중단시키는 선점 형 스케줄러는 나중에 나왔습니다. 선점형이 더 좋다고 할 수 있는 이유는,

(그림)
<center>
<img src="../assets/img/os/sunjum.png" style="width:80%;">
</center>


위 그림을 보면 비선점형의 경우 앞부분에서, 프로세스 1이 3개나 차지하고 있어서, 나머지 프로세스들은 오랜 기간동안 기다려야 합니다. 반면 선점형의 경우 여러개의 프로세스들이 두루두루 실행될 수 있습니다. 그래서 응답시간이 감소됩니다.


## 인터럽트

(그림)  

**인터럽트**
CPU가 프로그램을 실행하고 있을 떄 입출력 하드웨어 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술

**인터럽트가 필요한 때**  
- block상태를 끝내고 ready 상태로 전환되어야 할 떄 알려줘야합니다.
- 어느 한 순간 cpu가 실행하는 명령은 하나입니다. 그럼 다른 장치(입출력 하드웨어 장치 또는 예외상황)와 어떻게 커뮤니케이션을 할 것인지의 문제가 발생합니다.
- 이벤트 발생 --> 처리로 넘어갈때 인터럽트가 필요합니다. 
- 선점형 스케쥴러에서는 프로세스 running 중에 스케쥴러가 이것을 중단시킵니다. 이를 위해서는 스케쥴러 코드가 현 프로세스 실행을 중지시켜야합니다. 
- 저장 매체에서 데이터 처리를 완료했으면, block상태에 있던 프로세스를 깨워야합니다. 이것도 인터럽트라고 할 수 있습니다.
- 예외 상황 핸들링 : cpu가 프로그램 실행 중, 예외상황이 발생한 경우에는 cpu가 그것을 처리할수 있도록 cpu측에 알려줘야하는데, 이때 인터럽트가 필요합니다. 이런 상황이 발생하면 프로세스를 kill해줍니다. 

**인터럽트 처리 사례**
- 입출력 장치 이슈 발생시
  - 파일 처리가 끝났다는 사실을 운영체제에 알려줍니다.
  - 운영체제는 프로세스를 block --> ready로 전환합니다.
- 예외상황 발생시
  - 예외 발생을 운영체제에 알려줍니다.
  - 운영체제는 프로세스의 실행을 중지시키고 에러를 표시합니다.

```c
#include <stdio.h>
int main()
{
printf("Hello World!\n");
int data;
int divider = 0;
data = 1 / divider; // 인터럽트 발생
return 0;
}
```
- 타이머 인터럽트
  - 선점형 스케줄러를 구현하기 위해, 일정한 시간 구간마다 인터럽트를 발생시키는 것
  - 하드웨어로부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려줍니다. 
  
- 입출력 인터럽트
  - 프린터, 키보드, 마우스, 저장매체 등 여러 입출력 device가 있는데
  - 키보드 인터럽트: 키보드를 누르는 순간, 이 누른 사실(이벤트)을 운영체제에 알려준다.

**인터럽트 종류**

1. 내부 인터럽트(소프트웨어 인터럽트) : 프로그램 내부에서 예외상황이 발생했을 때
  - 0으로 나눈 코드 실행시
  - 포인터 주소가 잘못된 경우
  - overflow,underflow: int의 경우 32bit (unsigned, signed)이므로 숫자가 너무 커서 최대 2^31 또는 2^32 가지 숫자 범위를 넘어서면 overflow가 됩니다. 반대로 너무 작은 숫자로 범위를 넘어서면 underflow가 됩니다.

2. 외부 인터럽트(하드웨어 인터럽트): 하드웨어 발생하는 이벤트 발생 시
  - 전원이상
  - 기계문제
  - io 이벤트 등


**시스템 콜의 인터럽트**

시스템 콜은 내부적으로 인터럽트 방식으로 처리를 합니다.

- open이라는 함수를 실행한다면, (=인터럽트 발생함)
- open()이라는 시스템 콜을 호출해서 커널 모드로 전환됩니다.
- open()의 기계어의 구조
  - eax 레지스터에 시스템 콜 번호가 기입됩니다. (open에 해당하는 시스템콜 번호가 있음)
  - ebx 레지스터에 시스템 콜 인자값이 기입됩니다. (open의 경우 'data.txt', read_only 등 인자값)
  - 소프트웨어 인터럽트 명령을 호출합니다. int 0x80 (0x80은 시스템콜에 해당하는 인터럽트 번호입니다.)
- cpu는 인터럽트 0x80를 받습니다.
  - cpu는 사용자모드를 커널 모드로 바꿉니다.
- cpu는 IDT interrupt descriptor table 에서 0x80에 해당하는 함수를 찾아서 실행합니다.  

  |인터럽트 번호|주소(코드)|
  |--------|-----------|
  |0x80|유닉스계열의 system_call() 함수|

- system_call() 함수에서 eax에 적힌 시스템콜 번호를 가져옴. 그 번호에 해당하는 함수를 호출합니다.

  |%eax|커널 함수(system call)|%ebx|
  |1|sys_exit(exit)|int|
  |3|sys_read(read)|unsigned int|
  |5|sys_open(open)|const char*|
- 시스템콜 함수 실행후, 커널 모드에서 사용자 모드로 변경하고, 다음 코드를 진행합니다.

## IDT

- IDT는 인터럽트의 번호와 실행 코드를 가리키는 주소가 미리 정의해서 기록된 표입니다.  
- 이 표는 컴퓨터 부팅 시 운영체제가 기록합니다. 
- 실행 코드는 커널 모드에서의 코드입니다.  
- 리눅스의 경우  

|시스템콜 번호|인터럽트 종류|
|0~31|예외상황 인터럽트|
|32~47|하드웨어 인터럽트|
|128=0x80|시스템콜|




## Reference
- <a href="https://www.fastcampus.co.kr/dev_online_cs/">fast campus 강의</a>