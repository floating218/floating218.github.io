---
title : "[운영체제] 7. 가상 메모리"
excerpt : "페이징 시스템"
category :
  - os
tag :
  - os
use_math : true
author_profile : true
header:
  teaser : /assets/images/category/os.jpg
  overlay_image : /assets/images/category/os.jpg
  overlay_filter: 0.1
---

## 가상 메모리

**물리메모리의 한계**
프로세스는 메모리가 4기가 입니다. 각 프로세스마다 충분한 메모리를 할당하기에는 컴퓨터가 가진 (물리)메모리의 크기가 한계가 있습니다.  

예를 들어, 메모리 크기를 6기가라고 가정하면 메모리는 한번에 한 프로세스만 메모리에 넣을 수 있어서 비효율적입니다. 한 시점에서 cpu가 참조하는 메모리 크기는 별로 크지 않습니다. 왜냐면 한줄한줄씩만 읽기 때문입니다. 그러므로 프로세스는 필요한 공간만 메모리에 넣고 메모리 주소가 어딘지만 알면 됩니다. 

**가상메모리**
이 문제를 극복하기 위해 가상 메모리 시스템을 사용합니다. 가상 메모리는 여러 프로세스 동시에 실행하는 시스템에서 필요합니다.

<center><img src="../assets/img/os/minipagingsystem.png" style="width:80%;"></center>

1. virtual address 가상주소: 프로세스가 참조하는 주소 (0 ~ 4gb 이 중 일부분만 메모리에 올라갑니다.)
2. physical address 물리 주소: 실제 메모리 주소

가상주소를 물리주소를 변환해주는 매커니즘이 가상메모리에 있습니다. 가상 메모리의 매커니즘은 크게 두가지가 있습니다.  

1. 페이징 시스템
2. 세그멘테이션 


## 1. 페이징 시스템

<center><img src="../assets/img/os/pagingsystem2.png" style="width:100%;"></center>  

### 페이징 시스템의 개념  

페이징 시스템은 가상 메모리의 매커니즘 중 하나이며, 페이징이라는 개념을 사용합니다.  

**페이징**
크기가 동일한 **페이지**를 통해 가상 주소와 물리 주소를 관리하는 것. 리눅스는 4KB 단위로 페이징을 합니다. 예를 들어, 프로세스 메모리 공간이  4GB이라면 4GB를 4KB씩 쪼갭니다. 각각의 페이지는 번호를 붙입니다. 4kb만큼의 데이터는 물리 메모리에 올립니다. 실제 사이즈가 4KB가 안되더라도 빈 용량도 함께 물리 메모리 안에 넣습니다.

### **CPU, MMU, 메모리의 관계**

<center><img src="../assets/img/os/cpummumemory.png" style="width:80%;"></center>


1. 프로세스 생성시에 page table 정보도 함께 생성되며, 프로세스의 PCB는 Page table의 base 주소를 저장해 놓습니다. 
2. 프로세스 구동시에 cpu는 CR3 레지스터에 Page table의 base 주소를 저장합니다. 
3. CPU가 특정 데이터를 필요로 할때, MMU에 가상 주소 정보+Page table base 주소를 보냅니다. 
4. MMU는 Page table의 base 주소로 찾아가서, 물리주소를 요청합니다.
5. MMU는 물리주소를 알아낸다음, 물리주소에 접근해서 데이터를 가져옵니다. 
6. MMU는 데이터를 CPU에게 전달합니다.

**MMU(memory management unit)**
cpu에 코드 실행 시 가상 주소 메모리 접근이 필요할 때 가상 주소를 물리 주소로 변환해주는 하드웨어 장치입니다.  

**TLB**
최근에 변환되었던 가상주소 물리주소 정보를 가지고 있습니다. 그럼 페이지 테이블에 갔다오기 전에 tlb를 먼저 찾아봅니다. 메인메모리에 왔다갔다하는 시간을 절약해줍니다. 

**Page Table**
가상 주소와 물리 주소 외에, Valid- Invalid bit값을 가지고 있습니다. 모든 데이터를 물리 주소에 올릴 필요는 없기 때문에, 필요한 데이터만 물리 주소에 올려놓습니다. 물리 주소에 올려진 데이터는 valid 비트값을, 그렇지 않은 데이터는 invalid 비트값으로 표시합니다.  

### 페이지 폴트

<center><img src="../assets/img/os/pagefault.png" style="width:80%;"></center>


**요구 페이징(demand paging)**
page2를 쓰려고 했는데 아직 invalid 상태일 경우, 그 때 비로소 데이터를 물리 주소에 올려두고 page table을 업데이트합니다.

**Page fault**
인터럽트의 일종으로, 어떤 페이지가 실제 물리 메모리가 없을 때 일어나는 인터럽트입니다. 이 인터럽트를 받은 운영체제가 물리주소에 데이터를 올려주고 페이지 테이블도 업데이트해줍니다. 그리고 데이터 읽는 작업을 재시작합니다.

### 가상 주소와 물리 주소  

<center><img src="../assets/img/os/pagingsystem.png" style="width:80%;"></center>

**가상 주소의 구조**
cpu가 32비트일 경우  가상메모리 영역의 크기는 32비트입니다. 32비트로 4기가의 주소를 모두 표시할 수 있습니다.
- 가상주소 v=(p,d)
- p: 페이지 번호 (12-31비트)
- d: 페이지 처음부터 얼마나 떨어진 위치인가 (0-11비트,변위)

**물리 주소 찾기**
PCB에 있는 Page table base 주소를 알아낸다음, 여기에 페이지 번호를 더 알면(=가상주소를 알면), 해당 페이지의 물리주소도 알 수 있게 됩니다. 

- 물리주소 = p'+ d
- p' = page가 매핑된 첫 물리주소 
- d = 데이터가 첫 주소로부터 떨어진 거리 

**가상 주소와 물리 주소의 전환**
같은 페이지 번호이면, 같은 물리메모리 영역에 있습니다. d는 동일한 물리메모리 영역 내에서의 위치를 나타냅니다. 예를 들어 Page2의 4번째 데이터의 실제 위치는 0000h로 시작하는 물리메모리의 4번째 위치에 있습니다. 

### 페이지 교체 정책

물리 메모리가 꽉 찬 상태, 새로운 데이터를 넣어야하는 상황에서 어떤 페이지를 먼저 교체해야 하는가에 대한 정책  

**1. fifo**
가장 먼저 들어온 페이지를 내리는 페이지 교체 알고리즘

**2. OPT (optimal replacement algorithm)**
앞으로 가장 오랫동안 사용하지 않을 페이지를 내림. 일반 운영체제에서는 구현 불가능합니다

**3. LRU(least recently used)**
가장 오래된 페이지  

**4. LFU(least frequently used)**
가장 적게 사용된 패이지

LRU이 가장 많이 쓰입니다.

**스레싱thrashing** 반복적으로 페이지 폴트가 발생해서 과도하게 페이지 교체 작업이 일어나 실제로는 아무일도 하지 못하는 상황

### 다중 단계 페이징 시스템

4기가 중 대부분은 쓸모가 없으므로 공간 낭비입니다. 그래서 페이징 정보를 단계를 나누어 생성합니다. 필요한 부분만 테이블을 만들 수 있습니다 .linear address를 30비트짜리라고 할때,
- 상단 10bit: 페이지 디렉토리를 나타냄
- 중간 10bit:  페이지 디렉토리 중에서 사용되는 부분이면 page table의 위치를 나타냄니다
- 하단 12bit: 물리주소에서의 위치

## 2. 세그멘테이션 시스템 segmentation

<center><img src="../assets/img/os/segmentation.png" style="width:100%;"></center>

가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할 (페이징 기법에서는 같은 크기 블록으로 분할시킴)

**세그먼트 가상주소**
v=(s,d)=(세그먼트 번호,블록 내 세그먼트의 변위)

## 가상 메모리 정리

* 코드
코드는 컴파일되어 실행파일이 된다.
이 실행파일이 쉘을 통해 실행된다.
실행되면 프로세스가 생성된다.
프로세스가 차지하는 가상메모리는 4기가이다. 
0 ~ 0xff(4gb)
이것은 일종의 가상주소값이다.
코드는 사용자영역의 code부분에 들어간다. 
초기화되지 않은 변수 (int fd;)는 사용자영역의 bss부분에 들어간다. 
스택은 아직 공란이다. 
메인함수를 실행하면 스택이 사용될것입니다. 

필요없는 부분은
페이지 디렉토리 상에서 해당 페이지를 만들지 않으면 됩니다. 

## Reference

