---
title : "[운영체제] 6. 스레드"
excerpt : "thread, synchronization, semaphore, deadlock, starvation"
category :
  - os
tag :
  - os
use_math : true
author_profile : true
header:
  teaser : /assets/images/category/os.jpg
  overlay_image : /assets/images/category/os.jpg
  overlay_filter: 0.1
---

## 스레드란

<center>
<img src="../assets/img/os/thread0.png" style="width:60%;">
</center>   

**스레드**: 프로세스 안의 프로그램 실행의 흐름을 스레드라고 합니다. 스레드는 프로세스의 서브셋입니다. 

**멀티스레드**: 분기를 통해 여러개의 스레드를 한 프로세스 내에서 동시에 실행할 수 있습니다.


## 스레드의 메모리 공간

<center>
<img src="../assets/img/os/thread.png" style="width:50%;">
</center>  

- 스레드는 스택에 각 스레드별 별도의 공간을 배정받는 함수라고 할 수 있습니다. 
- 각 스레드마다 각자의 SP와 PC를 가지고 있습니다. 
- 하나의 프로세스 내에서의 스레드들은 프로세스의 영역(code, data, heap, 나머지 stack)을 공유합니다.


## 스레드와 프로세스의 비교

<center>
<img src="../assets/img/os/processvsthread.png" style="width:60%;">
</center>   
 

|프로세스|스레드|
|---|---|
|독립적|프로세스의 서브셋|
|독집적 자원|자원 공유|
|고유의 주소영역|주소영역 공유|
|ipc 기법으로 통신|필요없음|


## 스레드와 멀티프로세싱

앞에서 배운 운영체제의 운용방식을 복습해볼까요
- 멀티태스킹: 하나의 cpu로 여러 프로세스를 번갈아 실행
- 멀티프로세싱: 여러개의 cpu로 하나 또는 여러개의 프로세스를 실행시킴 (병렬 실행)

두 가지는 별개의 개념입니다. 스레드는 멀티프로세싱과 관련이 있는데요, 스레드를 여러 개 만들어서 멀티프로세싱을 가능하게 할 수 있습니다. 한 프로세스에서, 여러개의 스레드를 만들고, 각 스레드가 cpu별로 실행되게 한다면 멀티 코어 cpu를 최대한 활용할 수 있습니다.  

## 스레드와 운영체제

<center>
<img src="../assets/img/os/thread2.png" style="width:50%;">
</center>

운영체제를 만들때, 하나의 프로세스에 하나의 스레드만 있게 만들수있고 하나의 프로세스에 여러개의 스레드가 있게끔 만들수도 있다. 또한, 한편으로는 여러개의 프로세스를 동시에 실행하게 만들수도 있습니다. 


## 스레드의 장점과 단점

### 스레드의 장점

1. 사용자에 대한 응답성 향상
  - 어떤 작업을 하면서 동시에 사용자와 커뮤니케이션하는 작업도 할 수 있습니다. 
  - 하나의 프로세스가 여러개의 클라이언트에게 응답해주는 것이 힘듭니다. 그래서 클라이언트마다 별개의 스레드를 만들어서 처리해주는게 경제적입니다. 
2. 자원 공유 효율적
  - 하나의 프로세스 내에서 자원 공유가 가능하다
  - 6개의 프로세스가 있다고 치면, 각 프로세스 별로 4gb의 공간이 할당되므로, 24기가의 자원이 필요합니다
  - 반면 프로세스 안에 스레드 6개를 만들면, 6개의 스레드가 4기가의 공간을 공유하기 때문에 4기가만 차지하면 됩니다.

## 스레드의 단점

1. 스레드는 하나의 프로세스 안에서 움직이기 떄문에 한 스레드가 다른 스레드에 영향을 끼칩니다. 

2. context switching이 많이 일어나서 성능이 저하됩니다. 여러개의 스레드를 스케줄링해야하므로 복잡해지고 context switching이 빈번해집니다.

##  스레드를 코드에서 만드는 방법 
- Posix: 시스템콜을 만드는 api이다. 이 안에 thread 관련 표준 api가 있다. 

## 스레드의 동기화

### 동기화 이슈

동기화 이슈는 동일 자원을 여러 스레드가 동시 수정할 때, 각 스레드 결과에 영향을 주는 것입니다. 다음 예를 볼까요.  
 
- 스레드1: global 변수 g에 1을 더하는 스레드
- 스레드2: global 변수 g에 2를 더하는 스레드
- 스레드1,2를 실행해 g=0 을 g=3으로 만들려고 합니다.

동기화 문제를 해결하지 않으면 다음과 같은 문제가 발생합니다. 

1. 스레드1이 실행되기 시작합니다. 
2. 레지스터에 프로세스의 data 영역에 있는 g=0값이 저장됩니다.
3. 레지스터에서 연산이 수행되어 0->1이 됩니다.
4. data 영역에 저장하기 전에, 컨텍스트 스위칭이 발생합니다.
5. 스레드2가 실행되기 시작합니다.
6. 레지스터에 프로세스의 data 영역에 있는 g=0값이 저장됩니다.
7. 레지스터에서 연산이 수행되어 0->2가 됩니다.
8. data 영역에 저장하기 전에, 컨텍스트 스위칭이 발생합니다.
9. 스레드1이 이어서 실행됩니다. 
10. 레지스터에 있는 값 2가 data 영역에 덮어 씌워져서, g=2가 됩니다. 컨텍스트 스위칭됩니다
11. 스레드2이 이어서 실행됩니다.
12. data 영역에 똑같이 덮어씌워져서 그대로 g=2가 됩니다.
13. 그 결과, 스레드1의 연산 (더하기1)이 누락되었습니다.  

### 동기화 이슈 해결 방안

동기화는 동기화 이슈 문제를 해결하기 위해, 작업들 사이에 실행시기를 맞추는 것입니다.

```
lock.acquire() # 열쇠를 스레드a에게 줍니다
스레드a의 함수 실행
lock.release() # 열쇠를 반환합니다.  
```
동기화=locking 매커니즘

동기화 이슈는 실행시기를 맞추는것을 통해 해결합니다. 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 합니다.   

### 1. mutual exclusion

=mutex(binary semaphore)   

임계구역에 하나의 스레드만 들어갈 수 있습니다.

- critical resource(임계 자원) : 동시에 수정하면 안되는 공유 변수
- critical section (임계 영역) : 동시 실행되어서는 안되는 함수 영역


### 2. semaphore  

세마포는 임계구역에 여러 스레드가 들어갈 수 있는 기법입니다. **``counter``**를 두어서 동시에 리소스에 접근할 수 있는 허용 가능한 스레드 수를 제어합니다.

<center>
<img src="../assets/img/os/semaphore.png" style="width:80%;">
</center>


리눅스에는 P,S,V 세가지 함수로 구현되어 있습니다.  
1. p:검사(임계영역에 들어갈때), lock.acquire()
  - s값이 1이상이면 임계 영역 진입후 s에서 1뺍니다.
2. v: 증가(임계영역에서 나올때), lock.release()
  - s값에 1을 더하고 임계영역을 나옵니다.
3. s: 세마포어값 
  - 동시 접근 가능한 스레드 수를 설정한 것입니다. 초기값으로 설정된 카운트라고 할 수 있습니다.


## 교착 상태 (데드락)  

<center>
<img src="../assets/img/os/deadlock.png" style="width:60%;">
</center>

교착 상태 (Deadlock)은 무한 대기 상태를 의미합니다. 두개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 떄문에 다음 단계로 진행하지 못하는 것입니다. 데드락인 상황의 예는 다음과 같습니다.

```
#스레드1
lock.acquire(a)#a라는 임계자원을 lock함
use a
lock acquire(b)
lock.release(a)

#스레드2
lock.acquire(b)
use b
lock.acquire(a)
lock.release(b)
```

**교착 상태 발생 조건**  

1. mutual exclusion:  필요로하는 자원에 대해 배타적인 통제권을 요구합니다. 
2. hold and wait: 자원을 가진 상태에서(a) 또다른 자원을 기다립니다(b)
3. No preemption:  다른 스레드가 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없습니다.
4. circular wait: 순환적으로 다음 스레드가 요구하는 자원을 가지고 있습니다. 

**교착 상태 발견과 회복** 

교착 상태를 해결하려면 위 조건을 없애면 됩니다. 

## 기아 상태 (starvation)

특정 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태를 말합니다.

예를 들어 프로세스마다 우선순위가 다르다고 하면, 우선순위가 낮은 어떤 프로그램은 영원히 자원을 점유하지 못합니다. 

우선순위를 변경(수시로 변경, 오래 기다리면 우선순위를 올림, FIFO로 바꿈)함으로써 해결합니다. 

**교착상태와 기아상태**

교착상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생합니다

반면 기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때 특정 프로세스는 영원히 자원 할당이 안되는 경우를 의미합니다. 



