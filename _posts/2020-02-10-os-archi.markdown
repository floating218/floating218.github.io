---
layout: post
title:  "운영체제 구조"
date:   2020-02-10 13:36:15 +0900
categories: os
permalink: '/os/operating-archi'
---


## 운영체제를 도서관으로 비유하면?

- 운영체제는 도서관
- 응용 프로그램은 시민
- 하드웨어는 책

**운영체제는 뭘 하나요?**

1. 시민이 도서관에 책을 요청합니다.
> 응용프로그램이 운영체제에게 자원을 요청합니다.

2. 도서관은 책을 찾아서 시민에게 빌려줍니다. 
> 운영체제는 자원을 찾아서 응용프로그램에게 빌려줍니다.

3. 시민이 책을 다 읽거나, 기한이 다 되면, 도서관이 책을 회수합니다.
> 운영체제가 자원을 회수합니다. 

## 운영체제 - 응용프로그램 - 하드웨어의 관계

- 운영체제는 응용프로그램이 요청하는 메모리를 허가하고 분배합니다. 
- 운영체제는 응용프로그램이 요청하는 cpu 시간을 제공합니다.
- 운영체제는 응용프로그램이 요청하는 io 장치 사용을 허가하고 제어합니다. 

## 사용자 - 운영체제 - 응용프로그램 - 하드웨어의 관계

(그림) user-application-os-hardware

## 운영체제는 사용자 인터페이스를 제공합니다. 

**Shell**

쉘(shell) 은  사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 응용 프로그램입니다. 

쉘은 터미널 환경 CLI와 그래픽 환경 GUI로 분류합니다. 

## 운영체제는 응용프로그램을 위해서 인터페이스를 제공합니다. 

**API**

Application programming interface. api는 각 응용프로그램마다 함수로 제공됩니다. 보통은 이 함수들을 묶어서 라이브러리 형태로 제공합니다. 
- 예를 들어 clibrary에서 printf()도 api의 함수라고 할 수 있습니다. 

- 시민이 도서관에 책을 요청하기 위해서는 신청서를 작성해서 제출해야합니다.
> 사용자 또는 응용프로그램이 자원을 요청하기 위해서는 api형태의 요청서를 제출하여야 합니다. 

## 운영체제는 응용프로그램을 위해서 시스템콜을 제공합니다.  

**시스템콜**  
운영체제가 운영체제 각 기능을 사용할 수 있게하는 명령어 또는 함수를 제공하는데 이를 시스템콜이라고 합니다. 

api 내부에는 시스템콜을 호출하는 형태로 만들어집니다. 

전체 그림


1. 운영체제에게 자원을 요청하기 위해서는 요청서(시스템콜)가 필요합니다. 
2. 그런데 이 시스템콜을 직접 사용하기는 프로그래밍이 복잡합니다.
3. 그래서 이 문제를 완화하기 위해 각 언어별로 운영체제 기능을 요청할 수 있는 인터페이스(=api)를 제공합니다. api 내부에는 시스템콜이 있습니다. 
4. api,라이브러리를 기반으로 해서 application, shell등을 만듭니다.
5. 사용자는 application, shell등을 사용합니다. 

## 운영체제를 어떻게 만들까?

1. 운영체제를 개발합니다. = kernel
2. 시스템콜을 개발합니다.
3. c언어로 shell을 만들고 싶으면, c api(library)를 만들어야합니다.
4. c언어로 shell 프로그램을 만듭니다.
5. 응용프로그램을 만듭니다.

## 운영체제와 시스템콜

**POSIX API**  
표준적인 시스템콜을 정의하는 문서도 있습니다. 

**윈도우 API**
자기만의 규격입니다.

**맥**
리눅스의 시스템콜과 유사합니다.

## API와 시스템콜

- 시스템콜: 운영체제 기능을 호출하는 함수
- API: 각 언어별 운영체제 기능 호출 인터페이스 함수 (각 언어별 인터페이스)

## 요약

- 운영체제는 하드웨어와 응용 프로그램을 관리합니다. 
- 사용자 인터페이스를 제공하기 위해 쉘을 제공합니다. 
- 응용프로그램이 운영체제 기능을 요청하기 위해서 그 기능으로 운영체제는 시스템 콜을 제공합니다.
- 시스템콜을 c언어로 직접 사용할수는 있습니다만, 직접 사용하는 대신 시스템콜을 이용해서 만든 언어별 라이브러리인 api를 사용합니다. 

## CPU의 권한 모드, CPU protection rings

- user mode: 응용프로그램이 사용합니다.
- kernel mode: OS가 사용합니다. 특권 명령어 실행 및 원하는 작업 수행을 위한 자원 접근이 가능한 모드입니다. 

인텔 cpu를 기준으로, 4가지 모드 (ring0, ring1, ring2, ring3)를 가지고 있습니다. 그리고 대부분 그 중에서 2가지만 사용합니다. ring0이 커널 모드, ring3이 user 모드입니다.

**kernel이 뭐죠?**
> 사전적 번역은 알맹이, 핵심입니다. os가 cpu를 쓸때 사용하는 모드라고 할 수 있습니다. 

**shell이 뭐죠?**
> 사전적 번역은 껍데기입니다. 








## 운영체제 소개

### 1. 대표적인 운영체제

- windows os, mac os, unix(가장 현대 운영체제 기술을 최초로 구현함.)
- unix os 
    - 70년대부터 개발되었다.
    - unix 계열 os: 리눅스 os
        - unix와 사용법 및 os 구조가 유사한 os
    - 리눅스 os
        - 프로그래머, 전공자들이 잘 알아야하는 os
        - 인터넷 서비스를 구동시키는 서버 환경은 대부분 리눅스를 사용한다. 

### 2. 운영체제의 역할

> 1. 시스템 지원 관리자
> 2. 사용자와 컴퓨터 사이의 커뮤니케이션 지원
> 3. 컴퓨터 하드웨어와 프로그램을 제어

> 1. 시스템 자원 관리자 

    시스템 자원 = 하드웨어라고 보면됨.
        - cpu, memory, 입출력장치, 저장매체
    - 하드웨어는 스스로 할 수 있는 것이 없다. 
        - cpu: 각 프로그램이 얼마나 cpu를 사용할지 cpu가 알아서 결정할 수 없다. 그것은 운영체제가 결정해준다. 
        - memory: 각 프로그램이 어느 주소에, 얼만큼의 메모리 공간을 확보해줘야하는 지도 운영체제가 결정해준다. 
        - 저장 매체: 어디에 어떤 file명으로, 어떻게 저장할지 스스로 결정할 수 없으므로 운영체제가 결정해준다. 
        - 입출력장치: 스스로 표시할 수 없음. 
    - 그래서 운영체제가 필요하다. 
    - OS가 미설치된 노트북? os가 없으면 하드웨어를 제어할 수 없어서 동작을 안한다.  -

#### 2. 사용자와 컴퓨터 간의 커뮤니케이션을 지원

    - 사용자 <-> os <-> 컴퓨터 하드웨어
    - 사용자와 하드웨어 간의 커뮤니케이션을 중재하는 역할을 운영체제가 한다. os가 없다면, 사용자가 컴퓨터에 명령을 내릴 수 있는 수단이 없다.   
            

#### 3. 컴퓨터 하드웨어와 프로그램을 제어  

        - 하드웨어 뿐만 아니라 프로그램을 제어한다. 
        - (그림)
        - 응용 프로그램 <-> os <-> 컴퓨터 하드웨어
        - os 구성 요소  
            - shell 소프트웨어: user interface에 해당하며, gui, batch, command line 등이 있다. 
        - os의 system call들
            - process management
            - main memory management
            - file management
            - disk management
            - io management
            - networking protection
            

## 운영체제와 응용 프로그램


- 프로그램 = 소프트웨어 = 운영체제, 응용 프로그램 

### 1. 응용 프로그램 과의 관계

- 목표: 사용자가 사용하는 응용 프로그램이 효율적으로, 적절하게 동작하도록 지원해야함.

- 운영체제가 하는 일
    1. 응용 프로그램을 관리한다. 
        - **실행**시킨다.
        - **권한**을 관리해준다. 
            - 관리자 권한으로 실행
        - 응용프로그램의 **사용자**를 관리해준다. 
            - 로그인 기능
    2. 시스템 자원을 관리한다. 
    3. 사용자와 컴퓨터간의 커뮤니케이션을 지원한다. 

- 예시
    - 예를 들어, 응용 프로그램에 무한 반복문을 넣는 등 잘못 작성해서 프로그램이 다운되는 경우 운영체제가 비정상적 동작을 하는 프로그램을 중지 시키는 등 관리를 해줄 수 있다. 
    - 모든 파일 삭제 막기 (권한 / 사용자 관리)
    - 응용프로그램이 욕심이 많아서 cpu를 자기가 쓰겠다라고 하는 비정상적인 것을 운영체제가 막는다. 

### 2. 운영체제는 어디에 있을까?

- 운영체제는 SSD/HDD에 설치된다.

- 컴퓨터를 부팅시 --> 운영체제는 memory에 올라가게 됨



## 운영 체제 역사


|연도|요약|
|--|--|
|1950|운영체제가 없음|
|1960|배치 처리 시스템|
|1970|시분할시스템,멀티태스킹,멀티프로그래밍,unix(c언어)|
|1980|gui,pc도입|
|1990|다양한 응용 프로그램, 인터넷, 오픈 소스 운동|
|2000|오픈 소스 활성화, 가상머신, 대용량병렬처리|



### 1. 1950-1960

- 1950년대
    - **ENIAC** : 최초의 컴퓨터
    - 당시에는 운영체제가 없었다. 
    - 1개의 응용 프로그램을 실행시키기도 바빴음. 
    - 응용 프로그램이 시스템 자원을 직접 제어했음. 
    - 진공관을 가지고 0,1로 프로그램을 만들었다. 
- 1960년대 
    - 프로그램 종류가 많아지고 사용자도 많아지기 시작함. 
    - 앞 프로그램이 언제 끝날지 모른다. 
    - 앞 프로그램이 끝나면 자동으로 실행하게 하면 좋을 것 같다. 
    - **배치 처리 시스템** batch processing system
        - 여러 응용 프로그램을 등록시켜 놓고 순차적으로 실행하는 시스템
        - 운영체제의 기반

### 2. 1960 후반 - 시분할 시스템, 멀티태스킹

- 배치 처리 시스템의 단점
    - 컴퓨터 응답 시간이 오래 걸림 (앞단에 시간이 많이 필요한 프로그램이 있을 경우 뒷단의 프로그램은 오래 기다려야함.)
    - 실행 시간이 오래 걸림 (cpu가 필요없는 떄에도 응용프로그램이 cpu를 점유하고 있을 수 있으므로)

- 1960년대 후반
    - 시분할 시스템 time sharing system
    - 멀티 태스킹 multi tasking
    - 실제 구현되지는 않았음

- 시분할 시스템, 멀티 태스킹, 멀티 프로그래밍 
    - 응용 프로그램의 cpu 사용 시간을 잘개 쪼개서 여러개의 응용 프로그램을 동시에 실행하게 하는 기법
    - 컴퓨터 응답 시간을 줄일 수 있음 (시분할 시스템)
    - 전체 응용 프로그램의 실행 시간을 줄일 수 있음 (멀티 프로그래밍)
    - 여러 응용프로그램이 동시에 실행되는 것처럼 느껴진다 (멀티 태스킹)
- 시분할 시스템 time sharing system
    - 목적: 다중 사용자를 지원하고, 컴퓨터 응답 시간을 최소화하는 것을 목적으로 한다. 
    - app A이 8시간, app B이 3시간, app C이 2시간이 걸린다고 할 때,
        - 배치 처리 시스템에서는 하나씩 순차적으로 실행시킨다. 
        - 시분할 시스템: 다중 사용자를 지원한다. 
            - 다중 사용자를 지원하려면 컴퓨터 응답 시간을 최소화해야한다.
            - a-b-c-a-b-c-a-b-a-a-a-a-a 순으로 실행
- 멀티 태스킹 multi tasking
    - 목적: 가능한한 cpu를 많이 활용하도록 하는 기능
    - 멀티 태스킹: 단일 cpu에서 여러 응용프로그램의 병렬 실행을 가능케 하는 시스템
    - 시간을 잘게 쪼개서 마치 동시 실행인 것처럼 보이는 것을 구축한다. 
- 멀티 프로그래밍 multi programming 
    - 목적: 최대한 cpu를 많이 활용하도록 하기 위해 시간대비 cpu 활용도를 높이는 것. 
    - cpu에서 실행하는것과 저장매체 왔다갔다하는것은 시간 차이가 난다. 
    - 저장매체에서 읽어오는 시간 동안에 cpu에서 다른 응용프로그램으로 바꿔서 실행함. 
    - 저장매체에서 읽어오면 다시 원래의 프로그램을 실행함. 
    - cpu는 한번도 쉬지 않는다. 


### 4. 1970

- UNIX OS 출시
    - 미국 at&t의 벨 연구소에서 개발
        - 켄톰슨, 데니스 리치(c언어 개발자)
        - c언어로 만듦. 
    - 이전에는 assembly 언어로 소프트웨어 언어로 개발하였다. 
        - cpu 명령어, memory 물리적 주소를 직접 지정함.
        - 컴퓨터마다 각각 다시 개발해줘야하는 단점이 있음
        - 프로그래밍 복잡도가 높음. 
    - 1970년대에 c언어가 개발됨. 
        - 컴파일러 : c언어 코드를 어셈블리어로 바꿔준다. 
        - 프로그래밍 복잡도가 어셈블리 언어에 비해서는 낮다. 
    > c언어를 기반으로 운영체제를 개발했다. 
- UNIX의 특징
    - 현대 운영체제의 기본 기술을 모두 포함한 최초의 운영체제
        - 기본 기술
            - 멀티태스킹
            - 시분할 시스템
            - 멀티 프로그래밍
***

### 5. 1980

- 개인용 컴퓨터 시대 돌입.
    - 1980년대 이전에는 대형 컴퓨터를 여러명이 접속해서 사용했음 (UNIX) : 시분할 시스템 때문이었음. 다중 사용자를 지원했었다. 
    - 1980년대부터는 PC가 보급, 대중화되기 시작하는 시점임. 
    - 용어 이해
        - CLI: command line interface, 터미널 환경. 
        - GUI: graphical user interface, gui 환경.
    - 1980년대 초반은 거의 다 터미널 환경
    - 1980년대 후반부터 gui 환경 등장하기 시작. 
    - 참고영상 : microsoft & apple oss: a visual history
    - 1984년에 애플의 매킨토시에서 뭔가 gui스러운게 등장함. 마우스로 조작하기 시작함. 


### 6. 1990

- gui+pc 컴퓨터를 활용한 응용 프로그램 시대 개막
    - 엑셀, 워드 프로세서 등등
- window os의 대중화
- 네트워크 기술 발전으로 인한 www 인터넷 대중화
- 오픈 소스 운동 활성화 시작
    - unix os 개발 후, 기술을 공유해야한다는 주장 등장
    - unix 계열 ox + 응용 프로그램 개발한 소스를 오픈하기 시작
    - Linux 리눅스 os 등장 : 소스 오픈되며 무료임. 


### 7. 2000

- 오픈 소스 활성화
    -아파치: 웹서버라는 프로그램 중에 가장 유명하며, 오픈 소스임
    -리눅스: 운영체제
    -MySQL: 데이터베이스, 대용량 데이터를 관리하는 프로그램.
    -안드로이드, 딥러닝, 데이터사이언스, IoT 관련 소프트웨어가 오픈 소스로 만들어짐. 
- 가상 머신 기술, 대용량 병렬 처리 기술 활성화
    -컴퓨터 os에 os 여러개를 깔아서 동시 실행하게 함
    -cpu가 여러개 들어가 있는데, 여러개의 코어를 동시에 실행시킴.



### Reference
- <a href="http://www.fastcampus.co.kr">fast campus 강의</a>